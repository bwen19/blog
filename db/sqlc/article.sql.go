// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: article.sql

package db

import (
	"context"
	"time"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (
    author,
    category,
    title,
    summary,
    content
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, author, category, title, summary, content, status, view_count, update_at, create_at
`

type CreateArticleParams struct {
	Author   string `json:"author"`
	Category string `json:"category"`
	Title    string `json:"title"`
	Summary  string `json:"summary"`
	Content  string `json:"content"`
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Author,
		arg.Category,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Category,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Status,
		&i.ViewCount,
		&i.UpdateAt,
		&i.CreateAt,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles
WHERE id = $1
    AND ($2::bool OR author = $3::varchar)
    AND ($4::bool OR status = $5::varchar)
`

type DeleteArticleParams struct {
	ID        int64  `json:"id"`
	AnyAuthor bool   `json:"any_author"`
	Author    string `json:"author"`
	AnyStatus bool   `json:"any_status"`
	Status    string `json:"status"`
}

func (q *Queries) DeleteArticle(ctx context.Context, arg DeleteArticleParams) error {
	_, err := q.db.ExecContext(ctx, deleteArticle,
		arg.ID,
		arg.AnyAuthor,
		arg.Author,
		arg.AnyStatus,
		arg.Status,
	)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT id, author, category, title, summary, content, status, view_count, update_at, create_at FROM articles
WHERE id = $1
    AND ($2::bool OR author = $3::varchar)
LIMIT 1
`

type GetArticleParams struct {
	ID        int64  `json:"id"`
	AnyAuthor bool   `json:"any_author"`
	Author    string `json:"author"`
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, getArticle, arg.ID, arg.AnyAuthor, arg.Author)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Category,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Status,
		&i.ViewCount,
		&i.UpdateAt,
		&i.CreateAt,
	)
	return i, err
}

const listArticles = `-- name: ListArticles :many
SELECT
    id,
    author,
    category,
    title,
    summary,
    status,
    view_count,
    update_at
FROM articles
WHERE ($3::bool OR status = $4::varchar)
    AND ($5::bool OR author = $6::varchar)
    AND ($7::bool OR category = $8::varchar)
    AND ($9::bool OR id IN (
        SELECT article_id
        FROM article_tags
        WHERE tag = $10::varchar
    ))
ORDER BY
    CASE WHEN $11::bool THEN update_at END DESC,
    CASE WHEN $12::bool THEN view_count END DESC
LIMIT $1
OFFSET $2
`

type ListArticlesParams struct {
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
	AnyStatus   bool   `json:"any_status"`
	Status      string `json:"status"`
	AnyAuthor   bool   `json:"any_author"`
	Author      string `json:"author"`
	AnyCategory bool   `json:"any_category"`
	Category    string `json:"category"`
	AnyTag      bool   `json:"any_tag"`
	Tag         string `json:"tag"`
	TimeDesc    bool   `json:"time_desc"`
	CountDesc   bool   `json:"count_desc"`
}

type ListArticlesRow struct {
	ID        int64     `json:"id"`
	Author    string    `json:"author"`
	Category  string    `json:"category"`
	Title     string    `json:"title"`
	Summary   string    `json:"summary"`
	Status    string    `json:"status"`
	ViewCount int64     `json:"view_count"`
	UpdateAt  time.Time `json:"update_at"`
}

func (q *Queries) ListArticles(ctx context.Context, arg ListArticlesParams) ([]ListArticlesRow, error) {
	rows, err := q.db.QueryContext(ctx, listArticles,
		arg.Limit,
		arg.Offset,
		arg.AnyStatus,
		arg.Status,
		arg.AnyAuthor,
		arg.Author,
		arg.AnyCategory,
		arg.Category,
		arg.AnyTag,
		arg.Tag,
		arg.TimeDesc,
		arg.CountDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListArticlesRow{}
	for rows.Next() {
		var i ListArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Category,
			&i.Title,
			&i.Summary,
			&i.Status,
			&i.ViewCount,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readArticle = `-- name: ReadArticle :one
UPDATE articles
SET view_count = view_count + 1
WHERE id = $1
    AND status = 'published'
RETURNING id, author, category, title, summary, content, status, view_count, update_at, create_at
`

func (q *Queries) ReadArticle(ctx context.Context, id int64) (Article, error) {
	row := q.db.QueryRowContext(ctx, readArticle, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Category,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Status,
		&i.ViewCount,
		&i.UpdateAt,
		&i.CreateAt,
	)
	return i, err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE articles
SET
    author = CASE WHEN $2::bool
        THEN $3::varchar
        ELSE author END,
    category = CASE WHEN $4::bool
        THEN $5::varchar
        ELSE category END,
    title = CASE WHEN $6::bool
        THEN $7::varchar
        ELSE title END,
    summary = CASE WHEN $8::bool
        THEN $9::varchar
        ELSE summary END,
    content = CASE WHEN $10::bool
        THEN $11::text
        ELSE content END,
    status = CASE WHEN $12::bool
        THEN $13::varchar
        ELSE status END,
    view_count = CASE WHEN $14::bool
        THEN $15::bigint
        ELSE view_count END,
    update_at = now()
WHERE id = $1
    AND ($16::bool OR author = $17::varchar)
RETURNING id, author, category, title, summary, content, status, view_count, update_at, create_at
`

type UpdateArticleParams struct {
	ID           int64  `json:"id"`
	SetAuthor    bool   `json:"set_author"`
	Author       string `json:"author"`
	SetCategory  bool   `json:"set_category"`
	Category     string `json:"category"`
	SetTitle     bool   `json:"set_title"`
	Title        string `json:"title"`
	SetSummary   bool   `json:"set_summary"`
	Summary      string `json:"summary"`
	SetContent   bool   `json:"set_content"`
	Content      string `json:"content"`
	SetStatus    bool   `json:"set_status"`
	Status       string `json:"status"`
	SetViewCount bool   `json:"set_view_count"`
	ViewCount    int64  `json:"view_count"`
	AnyAuthor    bool   `json:"any_author"`
	Username     string `json:"username"`
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (Article, error) {
	row := q.db.QueryRowContext(ctx, updateArticle,
		arg.ID,
		arg.SetAuthor,
		arg.Author,
		arg.SetCategory,
		arg.Category,
		arg.SetTitle,
		arg.Title,
		arg.SetSummary,
		arg.Summary,
		arg.SetContent,
		arg.Content,
		arg.SetStatus,
		arg.Status,
		arg.SetViewCount,
		arg.ViewCount,
		arg.AnyAuthor,
		arg.Username,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Category,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.Status,
		&i.ViewCount,
		&i.UpdateAt,
		&i.CreateAt,
	)
	return i, err
}
